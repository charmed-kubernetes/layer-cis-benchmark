#!/usr/local/sbin/charm-env python3
import os
import json
import shlex
import shutil
import subprocess
import sys
import tempfile

from pathlib import Path

from charmhelpers.core import hookenv
from charmhelpers.fetch.archiveurl import ArchiveUrlFetchHandler
from charms.layer import snap
from charms.reactive import is_flag_set


BENCH_HOME = '/home/ubuntu/kube-bench'
BENCH_BIN = '{}/kube-bench'.format(BENCH_HOME)
BENCH_CFG = '{}/cfg'.format(BENCH_HOME)
GO_PKG = 'github.com/aquasecurity/kube-bench'
RESULTS_DIR = '/home/ubuntu/kube-bench-results'

# Remediation dicts associate a failing test with a command that will fix it
CONSERVATIVE = {
    '0.0.0': 'echo "this is fine"',
}
DANGEROUS = {
    '0.0.0': 'echo "this is fine"',
}


def _fail(msg):
    '''Fail the action with a given message.'''
    hookenv.action_fail(msg)
    sys.exit()


def _move_matching_parent(dirpath, filename, dest):
    '''Move a parent directory that contains a specific file.

    Helper function that walks a directory looking for a given file. If found,
    the file's parent directory is moved to the given destination.

    :param: dirpath: String path to search
    :param: filename: String file to find
    :param: dest: String destination of the found parent directory
    '''
    for root, _, files in os.walk(dirpath):
        for name in files:
            if name == filename:
                hookenv.log('Moving {} to {}'.format(root, dest))
                shutil.move(root, dest)
                return
    else:
        _fail('Could not find {} in {}'.format(filename, dirpath))


def install(release, config):
    '''Install kube-bench and related configuration.

    Release and configuration are set via action params. If installing an
    upstream release, this method will also install 'go' if needed.

    :param: release: Archive URI or 'upstream'
    :param: config: Archive URI of configuration files
    '''
    if Path(BENCH_HOME).exists():
        shutil.rmtree(BENCH_HOME)
    fetcher = ArchiveUrlFetchHandler()

    if release == 'upstream':
        Path(BENCH_HOME).mkdir(parents=True, exist_ok=True)

        # Setup the 'go' environment
        env = os.environ.copy()
        go_bin = shutil.which('go', path='{}:/snap/bin'.format(env['PATH']))
        if not go_bin:
            snap.install('go', channel='stable', classic=True)
            go_bin = '/snap/bin/go'
        go_cache = os.getenv('GOCACHE', '/var/snap/go/common/cache')
        go_path = os.getenv('GOPATH', '/var/snap/go/common')
        env['GOCACHE'] = go_cache
        env['GOPATH'] = go_path
        Path(go_path).mkdir(parents=True, exist_ok=True)

        # From https://github.com/aquasecurity/kube-bench#installing-from-sources
        go_cmd = ('{bin} get {pkg} '
                  'github.com/golang/dep/cmd/dep'.format(bin=go_bin, pkg=GO_PKG))
        try:
            subprocess.check_call(shlex.split(go_cmd), cwd=go_path, env=env)
        except subprocess.CalledProcessError:
            _fail('Failed to run: {}'.format(go_cmd))

        go_cmd = ('{bin} build -o {out} {base}/src/{pkg}'.format(
            bin=go_bin, out=BENCH_BIN, base=go_path, pkg=GO_PKG))
        try:
            subprocess.check_call(shlex.split(go_cmd), cwd=go_path, env=env)
        except subprocess.CalledProcessError:
            _fail('Failed to run: {}'.format(go_cmd))
    else:
        # Fetch the release URI and put it in the right place.
        archive_path = fetcher.install(source=release)
        # NB: We may not know the structure of the archive, but we know the
        # directory containing 'kube-bench' belongs in our BENCH_HOME.
        _move_matching_parent(
            dirpath=archive_path, filename='kube-bench', dest=BENCH_HOME)

    # Fetch the config URI and put it in the right place.
    archive_dir = fetcher.install(source=config)
    # NB: We may not know the structure of the archive, but we know the
    # directory containing 'config.yaml' belongs in our BENCH_CFG.
    _move_matching_parent(
        dirpath=archive_dir, filename='config.yaml', dest=BENCH_CFG)


def apply(remediations=None):
    '''Apply remediations to address benchmark failures.

    :param: remediations: either 'conservative' or 'dangerous'
    '''
    danger = True if remediations == 'dangerous' else False

    json_report = report(log_format='json')
    hookenv.log('Loading JSON from: {}'.format(json_report))
    try:
        with open(json_report, 'r') as f:
            full_json = json.load(f)
    except Exception:
        _fail('Failed to load: {}'.format(json_report))

    for test in full_json.get('tests', {}):
        for result in test.get('results', {}):
            test_num = result.get('test_number')
            test_status = result.get('status', '')

            if test_status.lower() == 'fail':
                test_remedy = CONSERVATIVE.get(test_num)
                if not test_remedy and danger:
                    test_remedy = DANGEROUS.get(test_num)
                if test_remedy:
                    hookenv.log('{} remediation is: {}'.format(test_num))
                else:
                    hookenv.log('{} remediation is missing'.format(test_num))


def report(log_format='text'):
    '''Run kube-bench and report results.

    By default, save the full plain-text results to our RESULTS_DIR and set
    action output with a summary. This function can also save full results in
    a machine-friendly json format.

    :param: log_format: String determines if output is text or json
    :returns: Path to results file
    '''
    Path(RESULTS_DIR).mkdir(parents=True, exist_ok=True)

    # Node type and config versions are different depending on the charm
    app = hookenv.charm_name() or 'unknown'
    if 'master' in app:
        node_type = 'master'
        version = '1.13-snap-k8s'
    elif 'worker' in app:
        node_type = 'node'
        version = '1.13-snap-k8s'
    elif 'etcd' in app:
        node_type = 'master'
        version = '1.13-snap-etcd'
    else:
        _fail('Unable to determine the node type to benchmark: {}'.format(app))

    if log_format == 'json':
        verbose_cmd = ('{bin} -D {cfg} --version {ver} --json {node}'.format(
            bin=BENCH_BIN, cfg=BENCH_CFG, ver=version, node=node_type))
        summary_cmd = None
        log_prefix = 'kube-bench-json-'
    else:
        verbose_cmd = ('{bin} -D {cfg} --version {ver} {node}'.format(
            bin=BENCH_BIN, cfg=BENCH_CFG, ver=version, node=node_type))
        summary_cmd = ('{bin} -D {cfg} --version {ver} --noremediations {node}'.format(
            bin=BENCH_BIN, cfg=BENCH_CFG, ver=version, node=node_type))
        log_prefix = 'kube-bench-txt-'

    # store full results for future consumption
    with tempfile.NamedTemporaryFile(mode='w+b', prefix=log_prefix,
                                     dir=RESULTS_DIR, delete=False) as res_file:
        try:
            subprocess.call(shlex.split(verbose_cmd), stdout=res_file)
        except subprocess.CalledProcessError:
            _fail('Failed to run: {}'.format(verbose_cmd))
        else:
            # remember the filename for later (and make it readable, why not?)
            Path(res_file.name).chmod(0o644)
            log = res_file.name

    # machines hate summaries
    if summary_cmd:
        try:
            out = subprocess.check_output(shlex.split(summary_cmd), universal_newlines=True)
        except subprocess.CalledProcessError:
            _fail('Failed to run: {}'.format(summary_cmd))
        else:
            # tell humans the command we ran as well as the summarized report
            hookenv.action_set({'cmd': verbose_cmd, 'summary': out})

    # tell whatever called us where we wrote this report
    return log if log else ''


if __name__ == '__main__':
    if not (is_flag_set('snap.installed.etcd') or
            is_flag_set('kubernetes-master.snaps.installed') or
            is_flag_set('kubernetes-worker.snaps.installed')):
        msg = 'Snaps are not yet installed on this unit.'
        _fail(msg)

    # Validate action params
    release = hookenv.action_get('release') or 'upstream'
    config = hookenv.action_get('config')
    if not config:
        msg = 'Missing "config" parameter'
        _fail(msg)
    remediations = hookenv.action_get('apply') or ''
    if remediations not in ['', 'conservative', 'dangerous']:
        msg = 'Invalid "apply" parameter: {}'.format(remediations)
        _fail(msg)

    # TODO: may want an option to overwrite an existing install
    if Path(BENCH_BIN).exists() and Path(BENCH_CFG).exists():
        hookenv.log('{} exists; skipping install'.format(BENCH_HOME))
    else:
        hookenv.log('Installing benchmark from: {}'.format(release))
        install(release, config)

    # If we have remediations to apply, do it before reporting results
    if remediations:
        hookenv.log('Applying "{}" remediations'.format(remediations))
        apply(remediations)
    else:
        hookenv.log('Report only; no remediations were requested')

    # Tell the people what they've won
    text_report = report(log_format='text')
    fetch_cmd = 'juju scp {unit}:{file} `pwd`'.format(unit=hookenv.local_unit(),
                                                      file=text_report)
    hookenv.action_set({'fetch-cmd': fetch_cmd})
